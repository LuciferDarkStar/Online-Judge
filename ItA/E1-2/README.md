# E1-2 股票
## 题目描述
小明是一个炒股爱好者，他准备分析某股票的历史交易信息。于是小明列出了该股票的历史价格，为数组$A$，数组中的每一个元素代表了第$i$天股票的价格，小明发现在股票的历史记录中有非常多类似于$i<j$，$A_i>A_j$的情况，在这些情况下，如果在第$i$天买入股票，并且在第$j$天卖出股票就会亏本，请你帮小明计算出，所有历史记录中，一共有多少个满足$i<j$，$A_i>A_j$的$(i,j)$对。
## 输入格式
输入一共两行，第一行为一个数字$n$，代表数组$A$的元素数目，即一共有多少天。

第二行一共有$n$个数字，代表每一天的股票价格。

假定股票价格为整数。

## 输出格式
输出共一个整数。

因为输出值可能非常大，请将输出的答案模$10,000,019$

## 数据规模
$0 < n \leq 1,000,0000 < n ≤ 1,000,000$

$0 \leq A_i\leq 10^9$

# 解题报告
## 初始思路
如果逐个检查，时间复杂度会达到$n^2$，这显然是无法接受的。

进一步考虑，本题的本质是求的给定数列的**逆序数**，由于只需要求得总的$(i,j)$对的数目，因此可以考虑在使用交换的排序过程中记录每一次交换所减少逆序对的数量，通过修改归并排序的算法，尝试在归并的过程中记录逆序数。
```c
int Merge(int *A, int p, int q, int r)
{
    unsigned long count = 0;
    int i, j, k;
    for (i = p, j = q + 1, k = p; i <= q && j <= r; k++)
    {
        if (A[i] <= A[j])
            B[k] = A[i++];
        else
        {
            B[k] = A[j++];
            count += (j - k - 1) % LIMIT; // 实质的逆序数
        }
    }
    while (i <= q)
        B[k++] = A[i++];
    while (j <= r)
        B[k++] = A[j++];
    for (i = p; i <= r; i++)
        A[i] = B[i];
    return (count % LIMIT);
}
```
修改后的归并排序算法中，归并会返回**在合并过程中，从后一部分前调的每个数所“跨过的”元素个数之和**。事实上，由于前后两个部分均已局部有序，当两两比较的合并过程中出现选取后一部分的某一元素时，意味着前一部分的其余元素均大于该元素，这就是该元素在本次合并过程中的逆序数。
```c
int MergeSort(int *A, int p, int r)
{
    int q;
    unsigned long count = 0;
    if (p < r)
    {
        q = (p + r) / 2;

        count += MergeSort(A, p, q) % LIMIT;
        count += MergeSort(A, q + 1, r) % LIMIT;
        count += Merge(A, p, q, r) % LIMIT;
        return count;
    }
    return 0;
}
```
## 提交过程与修改
第一次提交结果为[Partial Accepted](https://202.38.86.171/status/8a03e635c58ab5963304bab8680db552)，在最后两个测试点上出现了Wrong Answer，初步分析是由于对较大的结果取余出现了错误，经过几次尝试性提交后发现在`Merge`函数的返回值处没有进行取余，导致结果溢出。

以上问题修正之后提交结果顺利[AC](https://202.38.86.171/status/7345b6b24e6250dacee33d6837ad5f93)。
## 算法分析
### 时间复杂度
由于仅在归并排序的算法中加入了计数操作，因此渐进的时间复杂度不变，仍为$\Theta(n \lg{n})$。
### 空间复杂度
本例采用的算法实现中额外定义了一个数组来存放中间结果，空间复杂度为$O(2n)=O(n)$。
## 总结
逆序数是一个较为常见的数列统计概念，通过解答本题，对于基于比较的排序算法原理有了更深的理解，也能够通过修改已有的排序算法实现进一步的计数功能。