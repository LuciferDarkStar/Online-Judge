# E6-1 字符串匹配
## 题目描述
你需要求出模式串$P$在原串$S$中出现的次数, 模式串和原串中的字母均为小写, 数据有多组, 每组输出一个答案

## 输入格式
第一行为一个整数$T$, 表示你需要处理的数据组数

接下来$T$组, 每组第一行为模式串$P$, 第二行为原串$S$

## 输出格式
输出$T$行, 分别为每一组的答案

## 数据规模：
对于$100\%$的数据，$2 \leq T \leq 20$
对于$40\%$的数据, 模式串长度不超过$1000$, 原串长度不超过$10000$
对于$100\%$的数据, 模式串长度不超过$10000$, 原串长度不超过$1000000$

# 解题报告
## 初始思路
本题是单纯的*KMP*算法的实现，由于题目要求在一次执行中处理$T$组数据，为了紧凑化代码，没有使用二维数组存放每一组模式串的前缀函数数组，而是使用vector容器
```c++
vector<int> KMP;
```
```c++
KMP.clear();
KMP.resize(P.length());
```
较为直观地实现了算法导论中的伪代码表述：
> m = P.length
> let $\pi[1..m]$ be a new array

## 提交与修改过程
首次提交[Partial Accepted](https://202.38.86.171/status/426ef24afc7681edd30f028518fcb8a0)，第5个与第7个数据点出现了Runtime Error，判断是调用vector容器的`resize`方法时，传入参数是模式串长度`P.length()`，但在循环过程中：
```c++
for (int i = 1; i < P.length(); i++) // 模式串自己匹配自己
{
    while (k > 0 && P[k] != P[i])
        k = KMP[k];
    if (P[k] == P[i])
        k++;
    KMP[i + 1] = k;
}
```
可能会调用`KMP[i + 1]`，由于`clear`方法不改变容器容量，所以这个越界错误仅在部分数据点出现，修改`resize()`的参数后
```c++
KMP.clear();
KMP.resize(P.length() + 1);
```
提交通过，[Accepted](https://202.38.86.171/status/3e2c125f4691ce521388ba97663fe39a)。
## 算法分析
### 时间复杂度
`ComputePrefixFunction(P)`函数执行时，`while`循环最多迭代`P.length() - 1`次，消耗$O(m)$的时间，其中$m$是模式串的长度；而在函数`KMP_Matcher(string S, string P)`执行时，`for`循环体每一次迭代中，失配指针`q`最多增加1次，因此`q`最多增加`S.length()`次，消耗$O(n)$的时间，其中$n$是文本串的长度。因此算法总的时间复杂度是$\displaystyle \sum_{t = 1}^T{O(m_t + n_t)} = O\left(\sum_{t = 1}^T{(m_t + n_t)}\right)$。
### 空间复杂度
算法需要额外存储前缀函数数组`vector<int> KMP`，因此空间复杂度为$O(M)$，其中$M$是最长的模式串的长度。

## 总结
*KMP*算法代码并不复杂， 之所以其有着良好的性能，不仅仅是因为它的失配处理方案，更重要的是利用前缀后缀的特性，回避了多余的查找，代码中使用一重循环处理匹配，体现了其“最优历史处理”的性质。在本题的代码实现中，STL库的使用显得有些多余且消耗了一定的时间，但和算法本身并无太大关系。