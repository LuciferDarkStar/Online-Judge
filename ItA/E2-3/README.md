# E2-3 内存分配
## 题目描述
C语言中需要申请一块连续的内存时需要使用`malloc`等函数。如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针`NULL`。

现在小明决定实现一个类似`malloc`的内存分配系统，具体来说，他需要连续处理若干申请内存的请求，这个请求用一个闭区间$[a_i,\,b_i]$来表示。当这个区间和当前已被申请的内存产生重叠时，则返回内存分配失败的信息。否则返回内存分配成功，并将该区间标记为已被占用。

假设初始状态下内存均未被占用，管理的内存地址范围为0~1GB（$0~2^{30}$）。

## 输入格式
输入数据共$n+1$行。

第一行一个整数$n$表示共需要处理$n$次内存分配。

然后是$n$行数据，每行的格式为

$a_i b_i$

表示申请区间为$[a_i,\,b_i]$

## 输出格式
输出共$n$行。

对于每行内存分配的申请，若申请成功则输出一行$0$，若申请失败则输出一行$−1$。

## 数据规模：

$0 < n \leq 10^6$

$0 < a_i \leq b_i \leq 2^30$



# 解题报告
## 初始思路
这道题是较为标准的区间树或线段树的题目，考虑以CLRS算法导论的区间树扩张方法，在红黑树的基础上实现区间树，为每个结点增加区间域`interval`和子树最大端点`max`：
```c
typedef struct Interval
{
    int low;
    int high;
} Interval;
```
```c
// 区间树的节点
typedef struct IntervalTreeNode
{
    enum Color color;
    Interval interval;
    int max;
    struct IntervalTreeNode *left;
    struct IntervalTreeNode *right;
    struct IntervalTreeNode *parent;
} Node;
```
在向下查找和左右旋的操作中维护`max`的值。在本题中，对于每一个内存申请的区间，先查询区间树中是否存在与之重叠的结点，若不存在则将其插入树中。
```c
int Overlap(Interval i, Interval j)
{
    return (i.low <= j.high && j.low <= i.high);
}
```

## 提交与修改过程
初次提交[PA](https://202.38.86.171/status/7532b8f7b1fc1ba8ff1dade89002d842)且仅通过第一个测试点。
经过检查发现了在结点`max`属性维护部分的错误，修改后即[AC](https://202.38.86.171/status/1319b095546f56887cc3bbb82c658038)。

## 算法分析
### 时间复杂度
基于红黑树的区间树结构，对每一个区间，查询操作消耗$O(\lg{m})$的时间，其中$m$是已分配的内存区间即已插入的区间结点数，插入操作也消耗$O(\lg{m})$的时间，总的来说，算法的时间复杂度为$O(\lg{n})$。
### 空间复杂度
除了常数个数的变量空间之外，每一个成功的区间插入都消耗一个结构体的存储空间，因此算法的空间复杂度是$(n)$的。

## 总结
实验完成到本题时，由于已经有较多模板化的红黑树实现和扩张经历，参考CLRS教材以及此前实现的动态顺序统计红黑树，增加结点属性以维护区间树并没有遇到太多障碍。得益于红黑树的优良性质，提交的时间和空间占用也控制地比较客观。