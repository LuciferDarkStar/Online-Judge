# E1-EX 银行卡
## 题目描述
小明有一张银行卡，每天小明的爸爸都会往卡里打钱或者从卡里取钱，小明是一个可以预知未来的超能力者。他可以在每天预知到今天以及往后$k-1$天（包含今天的话总共$k$天）银行卡里钱的数目。每天晚上，小明都会思考今天以及接下来$k-1$天自己银行卡里最多会有多少钱（包含今天的话总共$k$天）。

给定一共$n$天小明银行卡钱的数目，求每天晚上小明算出的$k$天中最多的钱数目。
## 输入格式
第一行有两个数字 $n$和$k$。

第二行有$n$个整数代表每一天银行卡里钱的数目。
## 输出格式
输出一共$n−k+1$个数字，分别是每天晚上小明算出的结果（只需要求得前$n−k+1$天的结果）。
## 数据规模
$ 0 < k < n \leq 1000000 $
# 解题报告
## 初始思路
本题要求的是全部定长子序列中最大值的求得，直接计算的算法显然是$O(n \cdot k)$的。为降低时间复杂度，考虑用额外一个数组来记录每个子序列中最大值的位置，然而这样的算法实际上需要维护每个子序列中次大者的位置，而这样的维护对每个子序列而言依然是$O(k)$的复杂度。放弃了这一想法之后，联想到**最大优先队列**，维护一个$k$长的最大优先队列，在定长$k$的子序列“前移”的过程中，通过返回最大键字并将首个元素$A[i]$的键值增加（减少）到新加入的元素键值$A[i+k]$。
```c
void Heap_Change_Key(type *A, int i, type key)
{
    if (A[i].value == key.value)
        return;
    else if (key.value < A[i].value)
    {
        A[i].value = key.value;
        Max_Heapify(A, i);
    }
    else
    {
        A[i].value = key.value;
        while (i > 0 && A[Parent(i)].value < A[i].value)
        {
            Sequence[A[i].index].index = Parent(i);
            Sequence[A[Parent(i)].index].index = i;

            Swap(&A[i], &A[Parent(i)]);

            i = Parent(i);
        }
    }
    return;
}
```

然而随之出现的问题是，如何在已经维护好的优先队列中确定需要修改的键值的位置呢？这并不能被已有的堆维护算法很好的支持，但如果对每一个子序列都重新建堆，时间复杂度甚至超过了直接求最值。为解决这一问题，考虑用一个数组来存放**序列中的元素在子序列堆中的位置**，这对最大堆的维护提出了更高的要求——我们希望**堆中的每一个元素也能记住它在原始序列中的位置**。整理之后，决定采用以相同的结构体基类型的两个全局数组来分别存放原序列和子序列（优先队列）。
```c
typedef struct
{
    int value;
    int index; // 对于原序列，index存放的是该元素在优先队列堆中的下标；对于优先队列，index存放的是其在原序列中的下标
} type;

type Sequence[N];
type PriorQueue[N];
```
## 提交过程与修改
第一次提交结果为全部[Wrong Answer](https://202.38.86.171/status/97f87db159db84593e10c8fd5e2ae6c1)，初步分析是算法出了问题，但人工检查的部分数据没有发现问题，遂采用对拍检查，发现了一处`value`写成`index`的愚蠢错误。

稍加修改之后的提交依然[Partial Accepted](https://202.38.86.171/status/467bebcec4f0a60c2c26918d91104389)，但本次只有两个测试点未通过，而且本次提交的代码通过了10000次的全规模对拍。再次检查后发现问题来自于对堆中父亲结点的坐标计算函数`int Parent(int i)`出现了取整上的错误，而由于在堆的维护算法中对于父亲结点的计算出现频率较低，因此这个问题没有被有限次的对拍发现:skull_and_crossbones:。

在经过长达10分钟的对拍检查后的提交终于[AC](https://202.38.86.171/status/c3dfc8a683d5b74eb8a3fbf44d7065fe)，时间与空间占用也控制的很好。
## 算法分析

### 时间复杂度
建立优先队列的时间复杂度为$O(k \lg{k})$，对于每一个子序列，更新并维护优先队列`void Heap_Change_Key(type *A, int i, type key)`的时间复杂度为$O(\lg{k})$，因此总的时间复杂度为
$$
\begin{align*}
T(n,k) &= O(k \lg{k}) + n \cdot O(\lg{k}) \\
    &= O\big((n+k)\lg{k}\big) \\
    &= O(n\lg{k})
\end{align*}
$$
### 空间复杂度

理论上对于原始数组和优先队列，分别需要一个相同长度的额外数组来存储下标信息，因此空间复杂度为
$$
O(2n+2k) = O(n+k)
$$

## 总结
本题的难度相比本次试验的其他题目略有提升，但是解题思路是较为直接而清晰的：为了将时间复杂度从$O(n \cdot k)$降低，最可能的复杂度即为$O(n \cdot \lg{k})$，联想到基于排序算法的思路，在各种排序算法中，优先队列即堆排序显然最为合适，进而只需要用空间换时间以降低每次更新优先队列的时间即可。