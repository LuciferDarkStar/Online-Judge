# E2-2 军训排队
## 题目描述
现有$n$个学生排成一个固定队伍进行军训，教官小明有一份所有$n$个人的名单（不同的人可能重名）。小明想要在整个队伍中找到一个连续的子队伍，并且满足该子队的所有人恰好有$k$个不重复的名字。请帮小明计算一下一共有多少种可能的子队伍。

## 输入格式
一共有两行，第一行有两个数字$n$和$k$，用空格分隔

第二行有$n$个单词$name_i$​，用空格分隔

输入保证$len(name_i) \leq 5$（即输入的名字最多只含有$5$个字符）

## 输出格式
输出一共一个数字，即可能的子队伍数量。

## 数据规模：

$0 < k < n \leq 10000000$


# 解题报告
## 初始思路
连续子队伍可以看做一个变长的滑动窗口，通过设定两个指针`left`和`right`记录当前窗口位置。注意到输入中包含字符串，且需要考虑不重复的相异性判断，因此认为可能需要使用字符串Hash表来辅助实现，选择采用BKDR字符串Hash函数。
```c
int Hash_BKDR(char *S)
{
    int seed = 31;
    int hash = 0;

    for (; *S != '\0'; S++)
        hash = hash * seed + *S;
    return hash;
}
```
Hash表中存放字符串**出现的次数**，用`count`记录当前子队列中的相异元素个数，在其等于$k$时增加答案。

右指针的向右移动将字符串加入队列，将其插入Hash表即增加其出现的次数，且若此字符串仅在队列中出现一次，即与已有的各字符串相异，则需要增加`count`。左指针的向右移动将字符串移出队列，**在`count`的值比$k$大时**或**左指针指向的字符串重复出现时**需要向右移动左指针，直至`count`不大于`k`，并记录重复出现的字符个数以增加之后的子队列数目。
## 提交与修改过程
首次提交[PA](https://202.38.86.171/status/6d16318de52b36b1c9ec2bf8596cfdbd)，在最后三个测试点上出现了Wrong Answer的错误，初步考虑可能是Hash函数部分出了问题。调整Hash函数中的参数后出现了不同情况的Wrong Answer也证明了这一点。

考虑略微扩大Hash表的表长以降低装填因子，并修改BKDR函数中的种子值以适配如题所述“字符串长度不超过5”的情况进而减少冲突，随后即[AC](https://202.38.86.171/status/37a4acd4b2f9115dd04e4cc23d5a9a95)

## 算法分析
### 时间复杂度
关注窗口左指针和右指针的单向移动，尤其是外侧右指针循环内部的左指针移动是单向的，而Hash表的插入与查找都是$O(1)$时间。因此时间复杂度是$O(n)$的。
### 空间复杂度
需要存放全部的字符串，且每一个字符串都会进入Hash表，消耗$O(n)$的空间。

## 总结
本题主要分为滑动窗口和字符串散列两个部分。滑动窗口部分主要目的是通过记录字符串出现次数、局部重复次数、窗口内相异字符串数等，以空间换时间，将变长的窗口滑动控制在$O(n)$以内，核心部分是窗口左端重复出现的字符串次数需要被记录，因为在`count`不大于$key$的情况下，这些重复字符串一直需要被计算在内；字符串散列采用了比较常见的BKDR算法，并且根据条件调整了参数与表长。
