# E2-2 军训排队
## 题目描述
现有$n$个学生排成一个固定队伍进行军训，教官小明有一份所有$n$个人的名单（不同的人可能重名）。小明想要在整个队伍中找到一个连续的子队伍，并且满足该子队的所有人恰好有$k$个不重复的名字。请帮小明计算一下一共有多少种可能的子队伍。

## 输入格式
一共有两行，第一行有两个数字$n$和$k$，用空格分隔

第二行有$n$个单词$name_i$​，用空格分隔

输入保证$len(name_i) \leq 5$（即输入的名字最多只含有$5$个字符）

## 输出格式
输出一共一个数字，即可能的子队伍数量。

## 数据规模：

$0 < k < n \leq 10000000$


# 解题报告
## 初始思路
连续子队伍可以看做一个变长的滑动窗口，通过设定两个指针`left`和`right`记录当前窗口位置。注意到输入中包含字符串，且需要考虑不重复的相异性判断，因此认为可能需要使用字符串Hash表来辅助实现，选择采用BKDR字符串Hash函数。
```c
int Hash_BKDR(char *S)
{
    int seed = 31;
    int hash = 0;

    for (; *S != '\0'; S++)
        hash = hash * seed + *S;
    return hash;
}
```
Hash表中存放字符串**出现的次数**，用`count`记录当前子队列中的相异元素个数，在其等于$k$时增加答案。

右指针的向右移动将字符串加入队列，将其插入Hash表即增加其出现的次数，且若此字符串仅在队列中出现一次，即与已有的各字符串相异，则需要增加`count`。左指针的向右移动将字符串移出队列，**在`count`的值比$k$大时**或**左指针指向的字符串重复出现时**需要向右移动左指针，直至`count`不大于`k`。
## 提交与修改过程
首次提交[PA](https://202.38.86.171/status/6d16318de52b36b1c9ec2bf8596cfdbd)，在最后三个测试点上出现了Wrong Answer的错误，初步考虑可能是Hash函数部分出了问题。
## 算法分析
### 时间复杂度

### 空间复杂度

## 总结
