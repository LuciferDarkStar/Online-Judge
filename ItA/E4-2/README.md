# E4-2 任务调度
## 题目描述
现有$N$个任务需要在一台机器上进行调度，其中每个任务有相应的到达时间$r_i$r和执行时间$p_i$。

任务必须在到达之后才能进行执行，该机器同时只能执行一个任务。当一个任务在机器上执行$p_i$时间后，该任务即视为完成。若该任务的完成时刻为$f_i$，则该任务的响应时间为$f_i - r_i + 1$。

我们需要找到一个调度方案使所有任务的响应时间之和最短。

需要说明的是，在这个问题里我们假设已经将时间划分为若干不可再分的时隙，即一个任务最少的执行时间为1个单位时间，且任务只会在整数时刻到达。

此外，调度是可抢占的，这意味着在任意时隙开始时可以通过挂起正在执行的任务$i$转而执行另一项任务$j$，随后可以恢复任务$i$并执行其剩余的工作。

## 输入格式
第一行一个整数$N$表示总共的任务个数。

接下来的$N$行，每行两个整数$r_i,\,p_i$表示任务的到达时间和执行时间。

## 输出格式
输出一个整数表示最小的所有任务的总响应时间。

## 数据规模：
$ N \leq 100000$

$ r_i \leq 10000000$

$ p_i \leq 1000$

# 解题报告
## 初始思路
对于一个允许抢占的任务调度问题，基于**贪心**思想，采用类似于**最短剩余时间优先**(*Shortest-remaining-time-first*, SRTF)调度的算法设计。可以证明这样的调度算法是最优的，对于给定的一组任务，通过将剩余时间短的任务移到剩余时间长的任务之前执行，短任务响应时间的减少大于长进程响应时间的增加，因此总的响应时间减少。

由于任务的到达时间达到了$10^7$的量级，模拟调度显然是不可取的。首先根据任务的到达时间对其进行排序，再根据任务的剩余时间维护一个**优先队列**，队首是剩余时间最少的任务，也即当前执行的任务。在每一次任务到达时，减少队首任务的剩余时间，对其是否已完成进行判断，并将到达的任务入队，每当一个任务剩余时间为0时，将其出队并计算响应时间。
```c++
responseTime += Job[i - 1].arrival + current.remain - current.arrival; // Job[i - 1].arrival + current.remain 是当前任务的完成时间
```

## 提交与修改过程
首次提交[Partial Accepted](https://202.38.86.171/status/b1309483570a2f5019938ee5fc102a2f)。经过重新测试之后，发现前述算法忽略了两次任务到达之间，队首任务完成之后仍有时间供队列中的任务继续执行，从而产生了怠工时间。

## 算法分析
### 时间复杂度


### 空间复杂度


## 总结
