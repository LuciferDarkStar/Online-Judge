# E4-2 任务调度
## 题目描述
现有$N$个任务需要在一台机器上进行调度，其中每个任务有相应的到达时间$r_i$r和执行时间$p_i$。

任务必须在到达之后才能进行执行，该机器同时只能执行一个任务。当一个任务在机器上执行$p_i$时间后，该任务即视为完成。若该任务的完成时刻为$f_i$，则该任务的响应时间为$f_i - r_i + 1$。

我们需要找到一个调度方案使所有任务的响应时间之和最短。

需要说明的是，在这个问题里我们假设已经将时间划分为若干不可再分的时隙，即一个任务最少的执行时间为1个单位时间，且任务只会在整数时刻到达。

此外，调度是可抢占的，这意味着在任意时隙开始时可以通过挂起正在执行的任务$i$转而执行另一项任务$j$，随后可以恢复任务$i$并执行其剩余的工作。

## 输入格式
第一行一个整数$N$表示总共的任务个数。

接下来的$N$行，每行两个整数$r_i,\,p_i$表示任务的到达时间和执行时间。

## 输出格式
输出一个整数表示最小的所有任务的总响应时间。

## 数据规模：
$ N \leq 100000$

$ r_i \leq 10000000$

$ p_i \leq 1000$

# 解题报告
## 初始思路
对于一个允许抢占的任务调度问题，基于**贪心**思想，采用类似于**最短剩余时间优先**(*Shortest-remaining-time-first*, SRTF)调度的算法设计。可以证明这样的调度算法是最优的：对于给定的一组任务，通过将剩余时间短的任务移到剩余时间长的任务之前执行，短任务响应时间的减少大于长进程响应时间的增加，因此总的响应时间减少。

由于任务的到达时间达到了$10^7$的量级，模拟调度显然是不可取的。首先根据任务的到达时间对其进行排序，再根据任务的剩余时间维护一个**优先队列**，队首是剩余时间最少的任务，也即当前执行的任务。在每一次任务到达时，减少队首任务的剩余时间，对其是否已完成进行判断，并将到达的任务入队，每当一个任务剩余时间为0时，将其出队并计算响应时间。
```c++
responseTime += Job[i - 1].arrival + current.remain - current.arrival; // Job[i - 1].arrival + current.remain 是当前任务的完成时间
```

## 提交与修改过程
首次提交[Partial Accepted](https://202.38.86.171/status/b1309483570a2f5019938ee5fc102a2f)。经过重新测试之后，发现前述算法忽略了两次任务到达之间，队首任务完成之后仍有时间供队列中的任务继续执行，从而产生了怠工时间。

修改算法，对于两次任务到达之间的时间间隔，使用循环迭代确保没有时间浪费。
```c++
while (current.remain <= timeInterval)                  // 在任务到达之前，当前任务就可以完成
{
    responseTime += Job[i].arrival - timeInterval + current.remain - current.arrival; // Job[i].arrival - timeInterval + current.remain 是当前任务的完成时间
    timeInterval -= current.remain;                                                   // 工作时间
    current.remain = 0;
    if (JobQueue.empty())
        break;
    else
    {
        current = JobQueue.top(); // 当前执行的任务
        JobQueue.pop();
    }
}
```
再次提交[Accepted](https://202.38.86.171/status/7732a5db02792692b42e3725414179f3)

## 算法分析
### 时间复杂度
算法首先需要对输入数据进行排序，消耗$O( n \lg{n} )$的时间，随后进行的是$n$次的`for`循环迭代，以及$O(n)$次的`while`循环用于处理剩余任务，注意到每一个任务入队和出队的次数都不超过常数次，而优先队列入队消耗的时间是$O(\lg{n})$的，因此这部分也消耗$O(n \lg{n})$的时间。算法总的时间复杂度是$O(n \lg{n} )$。

### 空间复杂度
除了保存每一个任务的信息，额外维护的优先队列占用不超过$O(n)$的空间，总的空间复杂度是$O(n)$的。

## 总结
本题依然基于贪心的思想设计算法，借鉴了操作系统中进程调度的相关知识，借助优先队列实现基于SJF的算法，每次执行当前剩余时间最少的任务。考虑到数据规模，并没有盲目地模拟调度过程，而是通过迭代任务的到达计算总的响应时间，最终的时间也控制得比较好。